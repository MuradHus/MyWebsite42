<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ø¨Ø·ÙˆÙ„Ø© Ø§Ù„Ø£Ø¹Ù„Ø§Ù…: Ø§Ù„Ø³Ø¨Ø§Ù‚ ÙˆØ§Ù„Ù…Ø¹Ø±ÙƒØ©</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@700;900&display=swap');
        body {
            font-family: 'Cairo', sans-serif;
            background-color: #020617;
            margin: 0;
            overflow: hidden;
            color: white;
            user-select: none;
        }
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
        }
        .stage-title {
            text-align: center;
            text-shadow: 0 4px 10px rgba(0,0,0,0.8);
        }
        .qualifiers-list {
            position: absolute;
            left: 20px;
            top: 80px;
            display: flex;
            flex-direction: column;
            gap: 1.5px;
            opacity: 0.9;
        }
        .qualifier-item {
            background: rgba(30, 41, 59, 0.8);
            padding: 4px 10px;
            border-radius: 20px;
            border: 1px solid #3b82f6;
            font-size: 12px;
            animation: slideIn 0.3s ease-out;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        #winner-ui {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.95);
            z-index: 50;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        #countdown-text {
            margin-top: 20px;
            font-size: 14px;
            color: #cbd5e1;
        }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <div class="ui-overlay">
        <div class="stage-title">
            <h1 id="main-title" class="text-2xl font-black text-yellow-500 tracking-wider">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³Ù‚ÙˆØ·</h1>
            <p id="sub-title" class="text-sm text-slate-300">Ø£ÙˆÙ„ 10 Ø£Ø¹Ù„Ø§Ù… ØªØµÙ„ Ù„Ù„Ù†Ù‡Ø§ÙŠØ© ØªØªØ£Ù‡Ù„!</p>
        </div>
        
        <div id="qualifiers-container" class="qualifiers-list">
            <!-- Ø³ØªØ¸Ù‡Ø± Ø§Ù„Ø£Ø¹Ù„Ø§Ù… Ø§Ù„Ù…ØªØ£Ù‡Ù„Ø© Ù‡Ù†Ø§ -->
        </div>
    </div>

    <!-- Ø´Ø§Ø´Ø© Ø§Ù„ÙØ§Ø¦Ø² Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ -->
    <div id="winner-ui">
        <div class="text-center animate-bounce">
            <div class="text-red-500 font-bold mb-2 tracking-widest text-lg uppercase">ğŸ’€ Ø§Ù„Ù…ØºØ§Ø¯Ø± ğŸ’€</div>
            <div id="winner-flag" class="text-[80px] leading-none mb-4 drop-shadow-2xl"></div>
            <div id="winner-name" class="text-3xl font-black text-white mb-6"></div>
            <div class="w-20 h-1 bg-red-500 mx-auto rounded-full"></div>
            <div id="countdown-text" style="font-size: 12px; margin-top: 15px;">Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø© Ø³ØªØ¨Ø¯Ø£ Ø®Ù„Ø§Ù„ 6 Ø«ÙˆØ§Ù†Ù...</div>
        </div>
    </div>

    <script>
        const { Engine, Render, Runner, Bodies, Composite, Events, Body, Vector } = Matter;

        // --- Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø¹Ù„Ø§Ù… (Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„Ù„ØºØ§Øª) ---
        const flagsData = {
            "ar": [
                { name: "ÙÙ„Ø³Ø·ÙŠÙ†", emoji: "ğŸ‡µğŸ‡¸" }, { name: "Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©", emoji: "ğŸ‡¸ğŸ‡¦" }, { name: "Ù…ØµØ±", emoji: "ğŸ‡ªğŸ‡¬" },
                { name: "Ø§Ù„Ù…ØºØ±Ø¨", emoji: "ğŸ‡²ğŸ‡¦" }, { name: "Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±", emoji: "ğŸ‡©ğŸ‡¿" }, { name: "Ø§Ù„Ø£Ø±Ø¯Ù†", emoji: "ğŸ‡¯ğŸ‡´" },
                { name: "Ø§Ù„Ø¹Ø±Ø§Ù‚", emoji: "ğŸ‡®ğŸ‡¶" }, { name: "Ø§Ù„ÙƒÙˆÙŠØª", emoji: "ğŸ‡°ğŸ‡¼" }, { name: "Ø¹ÙÙ…Ø§Ù†", emoji: "ğŸ‡´ğŸ‡²" },
                { name: "Ù‚Ø·Ø±", emoji: "ğŸ‡¶ğŸ‡¦" }, { name: "ØªÙˆÙ†Ø³", emoji: "ğŸ‡¹ğŸ‡³" }, { name: "Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª", emoji: "ğŸ‡¦ğŸ‡ª" },
                { name: "Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†", emoji: "ğŸ‡§ğŸ‡­" }, { name: "Ø§Ù„ÙŠÙ…Ù†", emoji: "ğŸ‡¾ğŸ‡ª" }, { name: "Ù„Ø¨Ù†Ø§Ù†", emoji: "ğŸ‡±ğŸ‡§" },
                { name: "Ù„ÙŠØ¨ÙŠØ§", emoji: "ğŸ‡±ğŸ‡¾" }, { name: "Ø³ÙˆØ±ÙŠØ§", emoji: "ğŸ‡¸ğŸ‡¾" }, { name: "Ø§Ù„Ø³ÙˆØ¯Ø§Ù†", emoji: "ğŸ‡¸ğŸ‡©" },
                { name: "Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§", emoji: "ğŸ‡²ğŸ‡·" }, { name: "Ø§Ù„ØµÙˆÙ…Ø§Ù„", emoji: "ğŸ‡¸ğŸ‡´" }, { name: "Ø¬ÙŠØ¨ÙˆØªÙŠ", emoji: "ğŸ‡©ğŸ‡¯" },
                { name: "Ø¬Ø²Ø± Ø§Ù„Ù‚Ù…Ø±", emoji: "ğŸ‡°ğŸ‡²" }, 
                { name: "ØªØ±ÙƒÙŠØ§", emoji: "ğŸ‡¹ğŸ‡·" }, { name: "Ø£Ù„Ù…Ø§Ù†ÙŠØ§", emoji: "ğŸ‡©ğŸ‡ª" }, { name: "ÙØ±Ù†Ø³Ø§", emoji: "ğŸ‡«ğŸ‡·" },
                { name: "Ø¥Ø³Ø¨Ø§Ù†ÙŠØ§", emoji: "ğŸ‡ªğŸ‡¸" }, { name: "Ø¥ÙŠØ·Ø§Ù„ÙŠØ§", emoji: "ğŸ‡®ğŸ‡¹" }, { name: "Ø¨Ø±ÙŠØ·Ø§Ù†ÙŠØ§", emoji: "ğŸ‡¬ğŸ‡§" },
                { name: "Ø§Ù„Ø¨Ø±ØªØºØ§Ù„", emoji: "ğŸ‡µğŸ‡¹" }, { name: "Ù‡ÙˆÙ„Ù†Ø¯Ø§", emoji: "ğŸ‡³ğŸ‡±" }, { name: "Ø¨Ù„Ø¬ÙŠÙƒØ§", emoji: "ğŸ‡§ğŸ‡ª" },
                { name: "Ø³ÙˆÙŠØ³Ø±Ø§", emoji: "ğŸ‡¨ğŸ‡­" }, { name: "Ø§Ù„Ø³ÙˆÙŠØ¯", emoji: "ğŸ‡¸ğŸ‡ª" }, { name: "Ø§Ù„Ù†Ø±ÙˆÙŠØ¬", emoji: "ğŸ‡³ğŸ‡´" },
                { name: "Ø§Ù„Ø¯Ù†Ù…Ø§Ø±Ùƒ", emoji: "ğŸ‡©ğŸ‡°" }, { name: "ÙÙ†Ù„Ù†Ø¯Ø§", emoji: "ğŸ‡«ğŸ‡®" }, { name: "Ø£ÙŠØ±Ù„Ù†Ø¯Ø§", emoji: "ğŸ‡®ğŸ‡ª" },
                { name: "Ø¨ÙˆÙ„Ù†Ø¯Ø§", emoji: "ğŸ‡µğŸ‡±" }, { name: "Ø§Ù„Ù†Ù…Ø³Ø§", emoji: "ğŸ‡¦ğŸ‡¹" }, { name: "Ø§Ù„ÙŠÙˆÙ†Ø§Ù†", emoji: "ğŸ‡¬ğŸ‡·" },
                { name: "Ø±ÙˆØ³ÙŠØ§", emoji: "ğŸ‡·ğŸ‡º" }, { name: "Ø£ÙˆÙƒØ±Ø§Ù†ÙŠØ§", emoji: "ğŸ‡ºğŸ‡¦" }, { name: "ØµØ±Ø¨ÙŠØ§", emoji: "ğŸ‡·ğŸ‡¸" },
                { name: "ÙƒØ±ÙˆØ§ØªÙŠØ§", emoji: "ğŸ‡­ğŸ‡·" }, { name: "Ø§Ù„Ø¨ÙˆØ³Ù†Ø©", emoji: "ğŸ‡§ğŸ‡¦" }, { name: "Ø±ÙˆÙ…Ø§Ù†ÙŠØ§", emoji: "ğŸ‡·ğŸ‡´" },
                { name: "Ø¨Ù„ØºØ§Ø±ÙŠØ§", emoji: "ğŸ‡§ğŸ‡¬" }, { name: "Ø§Ù„Ù…Ø¬Ø±", emoji: "ğŸ‡­ğŸ‡º" }, { name: "Ø§Ù„ØªØ´ÙŠÙƒ", emoji: "ğŸ‡¨ğŸ‡¿" },
                { name: "Ø£Ù…Ø±ÙŠÙƒØ§", emoji: "ğŸ‡ºğŸ‡¸" }, { name: "ÙƒÙ†Ø¯Ø§", emoji: "ğŸ‡¨ğŸ‡¦" }, { name: "Ø§Ù„Ù…ÙƒØ³ÙŠÙƒ", emoji: "ğŸ‡²ğŸ‡½" },
                { name: "Ø§Ù„Ø¨Ø±Ø§Ø²ÙŠÙ„", emoji: "ğŸ‡§ğŸ‡·" }, { name: "Ø§Ù„Ø£Ø±Ø¬Ù†ØªÙŠÙ†", emoji: "ğŸ‡¦ğŸ‡·" }, { name: "ØªØ´ÙŠÙ„ÙŠ", emoji: "ğŸ‡¨ğŸ‡±" },
                { name: "ÙƒÙˆÙ„ÙˆÙ…Ø¨ÙŠØ§", emoji: "ğŸ‡¨ğŸ‡´" }, { name: "Ø¨ÙŠØ±Ùˆ", emoji: "ğŸ‡µğŸ‡ª" }, { name: "ÙÙ†Ø²ÙˆÙŠÙ„Ø§", emoji: "ğŸ‡»ğŸ‡ª" },
                { name: "Ø£ÙˆØ±ÙˆØºÙˆØ§ÙŠ", emoji: "ğŸ‡ºğŸ‡¾" }, { name: "Ø¨Ø§Ø±Ø§ØºÙˆØ§ÙŠ", emoji: "ğŸ‡µğŸ‡¾" }, { name: "Ø§Ù„Ø¥ÙƒÙˆØ§Ø¯ÙˆØ±", emoji: "ğŸ‡ªğŸ‡¨" },
                { name: "Ø§Ù„ØµÙŠÙ†", emoji: "ğŸ‡¨ğŸ‡³" }, { name: "Ø§Ù„ÙŠØ§Ø¨Ø§Ù†", emoji: "ğŸ‡¯ğŸ‡µ" }, { name: "ÙƒÙˆØ±ÙŠØ§ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ©", emoji: "ğŸ‡°ğŸ‡·" },
                { name: "ÙƒÙˆØ±ÙŠØ§ Ø§Ù„Ø´Ù…Ø§Ù„ÙŠØ©", emoji: "ğŸ‡°ğŸ‡µ" }, { name: "Ø§Ù„Ù‡Ù†Ø¯", emoji: "ğŸ‡®ğŸ‡³" }, { name: "Ø¨Ø§ÙƒØ³ØªØ§Ù†", emoji: "ğŸ‡µğŸ‡°" },
                { name: "Ø¥Ù†Ø¯ÙˆÙ†ÙŠØ³ÙŠØ§", emoji: "ğŸ‡®ğŸ‡©" }, { name: "Ù…Ø§Ù„ÙŠØ²ÙŠØ§", emoji: "ğŸ‡²ğŸ‡¾" }, { name: "Ø§Ù„ÙÙ„Ø¨ÙŠÙ†", emoji: "ğŸ‡µğŸ‡­" },
                { name: "ÙÙŠØªÙ†Ø§Ù…", emoji: "ğŸ‡»ğŸ‡³" }, { name: "ØªØ§ÙŠÙ„Ø§Ù†Ø¯", emoji: "ğŸ‡¹ğŸ‡­" }, { name: "Ø³Ù†ØºØ§ÙÙˆØ±Ø©", emoji: "ğŸ‡¸ğŸ‡¬" },
                { name: "Ø¨Ù†ØºÙ„Ø§Ø¯ÙŠØ´", emoji: "ğŸ‡§ğŸ‡©" }, { name: "Ø£ÙØºØ§Ù†Ø³ØªØ§Ù†", emoji: "ğŸ‡¦ğŸ‡«" }, { name: "Ø¥ÙŠØ±Ø§Ù†", emoji: "ğŸ‡®ğŸ‡·" },
                { name: "Ø£Ø³ØªØ±Ø§Ù„ÙŠØ§", emoji: "ğŸ‡¦ğŸ‡º" }, { name: "Ù†ÙŠÙˆØ²ÙŠÙ„Ù†Ø¯Ø§", emoji: "ğŸ‡³ğŸ‡¿" }, 
                { name: "Ø¬Ù†ÙˆØ¨ Ø£ÙØ±ÙŠÙ‚ÙŠØ§", emoji: "ğŸ‡¿ğŸ‡¦" }, { name: "Ù†ÙŠØ¬ÙŠØ±ÙŠØ§", emoji: "ğŸ‡³ğŸ‡¬" }, { name: "ØºØ§Ù†Ø§", emoji: "ğŸ‡¬ğŸ‡­" },
                { name: "Ø§Ù„Ø³Ù†ØºØ§Ù„", emoji: "ğŸ‡¸ğŸ‡³" }, { name: "Ø§Ù„ÙƒØ§Ù…ÙŠØ±ÙˆÙ†", emoji: "ğŸ‡¨ğŸ‡²" }, { name: "ÙƒÙˆØ¯ÙŠÙÙˆØ§Ø±", emoji: "ğŸ‡¨ğŸ‡®" },
                { name: "ÙƒÙŠÙ†ÙŠØ§", emoji: "ğŸ‡°ğŸ‡ª" }, { name: "Ø¥Ø«ÙŠÙˆØ¨ÙŠØ§", emoji: "ğŸ‡ªğŸ‡¹" }, { name: "ØªÙ†Ø²Ø§Ù†ÙŠØ§", emoji: "ğŸ‡¹ğŸ‡¿" }
            ],
            "en": [
                { name: "Palestine", emoji: "ğŸ‡µğŸ‡¸" }, { name: "Saudi Arabia", emoji: "ğŸ‡¸ğŸ‡¦" }, { name: "Egypt", emoji: "ğŸ‡ªğŸ‡¬" },
                { name: "Morocco", emoji: "ğŸ‡²ğŸ‡¦" }, { name: "Algeria", emoji: "ğŸ‡©ğŸ‡¿" }, { name: "Jordan", emoji: "ğŸ‡¯ğŸ‡´" },
                { name: "Iraq", emoji: "ğŸ‡®ğŸ‡¶" }, { name: "Kuwait", emoji: "ğŸ‡°ğŸ‡¼" }, { name: "Oman", emoji: "ğŸ‡´ğŸ‡²" },
                { name: "Qatar", emoji: "ğŸ‡¶ğŸ‡¦" }, { name: "Tunisia", emoji: "ğŸ‡¹ğŸ‡³" }, { name: "UAE", emoji: "ğŸ‡¦ğŸ‡ª" },
                { name: "Bahrain", emoji: "ğŸ‡§ğŸ‡­" }, { name: "Yemen", emoji: "ğŸ‡¾ğŸ‡ª" }, { name: "Lebanon", emoji: "ğŸ‡±ğŸ‡§" },
                { name: "Libya", emoji: "ğŸ‡±ğŸ‡¾" }, { name: "Syria", emoji: "ğŸ‡¸ğŸ‡¾" }, { name: "Sudan", emoji: "ğŸ‡¸ğŸ‡©" },
                { name: "Mauritania", emoji: "ğŸ‡²ğŸ‡·" }, { name: "Somalia", emoji: "ğŸ‡¸ğŸ‡´" }, { name: "Djibouti", emoji: "ğŸ‡©ğŸ‡¯" },
                { name: "Comoros", emoji: "ğŸ‡°ğŸ‡²" }, 
                { name: "Turkey", emoji: "ğŸ‡¹ğŸ‡·" }, { name: "Germany", emoji: "ğŸ‡©ğŸ‡ª" }, { name: "France", emoji: "ğŸ‡«ğŸ‡·" },
                { name: "Spain", emoji: "ğŸ‡ªğŸ‡¸" }, { name: "Italy", emoji: "ğŸ‡®ğŸ‡¹" }, { name: "UK", emoji: "ğŸ‡¬ğŸ‡§" },
                { name: "Portugal", emoji: "ğŸ‡µğŸ‡¹" }, { name: "Netherlands", emoji: "ğŸ‡³ğŸ‡±" }, { name: "Belgium", emoji: "ğŸ‡§ğŸ‡ª" },
                { name: "Switzerland", emoji: "ğŸ‡¨ğŸ‡­" }, { name: "Sweden", emoji: "ğŸ‡¸ğŸ‡ª" }, { name: "Norway", emoji: "ğŸ‡³ğŸ‡´" },
                { name: "Denmark", emoji: "ğŸ‡©ğŸ‡°" }, { name: "Finland", emoji: "ğŸ‡«ğŸ‡®" }, { name: "Ireland", emoji: "ğŸ‡®ğŸ‡ª" },
                { name: "Poland", emoji: "ğŸ‡µğŸ‡±" }, { name: "Austria", emoji: "ğŸ‡¦ğŸ‡¹" }, { name: "Greece", emoji: "ğŸ‡¬ğŸ‡·" },
                { name: "Russia", emoji: "ğŸ‡·ğŸ‡º" }, { name: "Ukraine", emoji: "ğŸ‡ºğŸ‡¦" }, { name: "Serbia", emoji: "ğŸ‡·ğŸ‡¸" },
                { name: "Croatia", emoji: "ğŸ‡­ğŸ‡·" }, { name: "Bosnia", emoji: "ğŸ‡§ğŸ‡¦" }, { name: "Romania", emoji: "ğŸ‡·ğŸ‡´" },
                { name: "Bulgaria", emoji: "ğŸ‡§ğŸ‡¬" }, { name: "Hungary", emoji: "ğŸ‡­ğŸ‡º" }, { name: "Czechia", emoji: "ğŸ‡¨ğŸ‡¿" },
                { name: "USA", emoji: "ğŸ‡ºğŸ‡¸" }, { name: "Canada", emoji: "ğŸ‡¨ğŸ‡¦" }, { name: "Mexico", emoji: "ğŸ‡²ğŸ‡½" },
                { name: "Brazil", emoji: "ğŸ‡§ğŸ‡·" }, { name: "Argentina", emoji: "ğŸ‡¦ğŸ‡·" }, { name: "Chile", emoji: "ğŸ‡¨ğŸ‡±" },
                { name: "Colombia", emoji: "ğŸ‡¨ğŸ‡´" }, { name: "Peru", emoji: "ğŸ‡µğŸ‡ª" }, { name: "Venezuela", emoji: "ğŸ‡»ğŸ‡ª" },
                { name: "Uruguay", emoji: "ğŸ‡ºğŸ‡¾" }, { name: "Paraguay", emoji: "ğŸ‡µğŸ‡¾" }, { name: "Ecuador", emoji: "ğŸ‡ªğŸ‡¨" },
                { name: "China", emoji: "ğŸ‡¨ğŸ‡³" }, { name: "Japan", emoji: "ğŸ‡¯ğŸ‡µ" }, { name: "South Korea", emoji: "ğŸ‡°ğŸ‡·" },
                { name: "North Korea", emoji: "ğŸ‡°ğŸ‡µ" }, { name: "India", emoji: "ğŸ‡®ğŸ‡³" }, { name: "Pakistan", emoji: "ğŸ‡µğŸ‡°" },
                { name: "Indonesia", emoji: "ğŸ‡®ğŸ‡©" }, { name: "Malaysia", emoji: "ğŸ‡²ğŸ‡¾" }, { name: "Philippines", emoji: "ğŸ‡µğŸ‡­" },
                { name: "Vietnam", emoji: "ğŸ‡»ğŸ‡³" }, { name: "Thailand", emoji: "ğŸ‡¹ğŸ‡­" }, { name: "Singapore", emoji: "ğŸ‡¸ğŸ‡¬" },
                { name: "Bangladesh", emoji: "ğŸ‡§ğŸ‡©" }, { name: "Afghanistan", emoji: "ğŸ‡¦ğŸ‡«" }, { name: "Iran", emoji: "ğŸ‡®ğŸ‡·" },
                { name: "Australia", emoji: "ğŸ‡¦ğŸ‡º" }, { name: "New Zealand", emoji: "ğŸ‡³ğŸ‡¿" }, 
                { name: "South Africa", emoji: "ğŸ‡¿ğŸ‡¦" }, { name: "Nigeria", emoji: "ğŸ‡³ğŸ‡¬" }, { name: "Ghana", emoji: "ğŸ‡¬ğŸ‡­" },
                { name: "Senegal", emoji: "ğŸ‡¸ğŸ‡³" }, { name: "Cameroon", emoji: "ğŸ‡¨ğŸ‡²" }, { name: "Ivory Coast", emoji: "ğŸ‡¨ğŸ‡®" },
                { name: "Kenya", emoji: "ğŸ‡°ğŸ‡ª" }, { name: "Ethiopia", emoji: "ğŸ‡ªğŸ‡¹" }, { name: "Tanzania", emoji: "ğŸ‡¹ğŸ‡¿" }
            ]
        };

        // --- Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© ---
        let engine, render, runner;
        let width, height;
        let stage = 1; 
        let qualifiedFlags = [];
        let bullets = [];
        let breakables = []; // New: Breakable obstacles
        let stage2Flags = []; 
        let stage3Flags = [];
        let lasers = [];
        let diceRolls = []; // Objects { flag, value, timer }
        let currentLang = 'ar';
        
        // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø¯ÙØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        let cannonAngle = 0;
        let cannonTargetAngle = 0;
        let cannonState = 'aiming'; // 'aiming' or 'cooldown'
        let shotCounter = 0; // Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø·Ù„Ù‚Ø§Øª Ù„Ù„ÙƒØ±Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©
        
        // Stage 3 Variables
        let laserCycle = 0;
        let laserState = 'idle'; // idle, warning, firing
        let laserTimer = 0;
        let activeLaserCount = 1;
        
        const canvas = document.getElementById('game-canvas');
        
        function getSavedLanguage() {
            return localStorage.getItem('language') || 'ar';
        }

        function init() {
            // Stage 3 Variables Init
            stage3Flags = [];
            lasers = [];
            diceRolls = [];
            laserCycle = 0;
            activeLaserCount = 1;
            laserState = 'idle';
            
            currentLang = getSavedLanguage();
            // Updat title based on language
            const titles = {
                'ar': { main: "Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³Ù‚ÙˆØ·", sub: "Ø£ÙˆÙ„ 10 Ø£Ø¹Ù„Ø§Ù… ØªØµÙ„ Ù„Ù„Ù†Ù‡Ø§ÙŠØ© ØªØªØ£Ù‡Ù„!" },
                'en': { main: "Stage 1: The Drop Race", sub: "First 10 flags to reach the bottom qualify!" }
            };
            document.getElementById('main-title').innerText = titles[currentLang].main;
            document.getElementById('sub-title').innerText = titles[currentLang].sub;
            document.documentElement.lang = currentLang;
            document.documentElement.dir = currentLang === 'ar' ? 'rtl' : 'ltr';

            width = window.innerWidth;
            height = window.innerHeight;

            canvas.width = width;
            canvas.height = height;

            engine = Engine.create();
            render = Render.create({
                canvas: canvas,
                engine: engine,
                options: {
                    width: width,
                    height: height,
                    wireframes: false,
                    background: 'transparent'
                }
            });

            window.addEventListener('resize', () => {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
                render.options.height = height;
                
                if (stage === 2) {
                    repositionStage2Flags();
                }
            });

            startStage1();
            
            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            Events.on(render, 'afterRender', renderCustomGraphics);
            Events.on(engine, 'beforeUpdate', updateLoop); // Ø­Ù„Ù‚Ø© ØªØ­Ø¯ÙŠØ« Ø¹Ø§Ù…Ø©
            Events.on(engine, 'collisionStart', handleCollisions);
        }

        function resetGame() {
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª
            stage = 1;
            qualifiedFlags = [];
            bullets = [];
            stage2Flags = [];
            cannonAngle = 0;
            cannonState = 'aiming';
            shotCounter = 0;

            // ØªÙ†Ø¸ÙŠÙ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            document.getElementById('winner-ui').style.display = 'none';
            document.getElementById('qualifiers-container').innerHTML = '';
            document.getElementById('main-title').innerText = "Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³Ù‚ÙˆØ·";
            document.getElementById('main-title').className = "text-2xl font-black text-yellow-500 tracking-wider";
            document.getElementById('sub-title').innerText = "Ø£ÙˆÙ„ 10 Ø£Ø¹Ù„Ø§Ù… ØªØµÙ„ Ù„Ù„Ù†Ù‡Ø§ÙŠØ© ØªØªØ£Ù‡Ù„!";

            // ØªÙ†Ø¸ÙŠÙ Ø¹Ø§Ù„Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡
            Composite.clear(engine.world);
            Engine.clear(engine);

            // Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
            startStage1();
        }

        // ==========================================
        // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³Ù‚ÙˆØ·
        // ==========================================
        function startStage1() {
            engine.gravity.y = 1;

            const walls = [
                Bodies.rectangle(-10, height/2, 20, height*2, { isStatic: true }),
                Bodies.rectangle(width+10, height/2, 20, height*2, { isStatic: true }),
                Bodies.rectangle(width/2, height + 50, width, 100, { isStatic: true, label: 'finishLine', isSensor: true })
            ];
            Composite.add(engine.world, walls);

            const rows = 10; // Reduced rows slightly for better flow
            const cols = Math.floor(width / 60);
            breakables = [];
            
            for(let r=1; r<rows; r++) {
                for(let c=1; c<cols; c++) {
                    const x = (width / cols) * c + (r%2 === 0 ? 20 : -20);
                    const y = (height / rows) * r + 50;
                    
                    // Breakable Obstacle (Random HP 1-6)
                    const hp = Math.floor(Math.random() * 6) + 1;
                    const radius = 13;
                    
                    const obstacle = Bodies.circle(x, y, radius, { 
                        isStatic: true,
                        label: 'breakable',
                        render: { fillStyle: getObstacleColor(hp) } 
                    });
                    
                    obstacle.hp = hp;
                    obstacle.maxHp = hp;
                    breakables.push(obstacle);
                    Composite.add(engine.world, obstacle);
                }
            }

            const flags = flagsData[currentLang] || flagsData['ar'];
            const shuffled = [...flags].sort(() => Math.random() - 0.5);
            shuffled.forEach((flag, i) => {
                setTimeout(() => {
                    if (stage !== 1) return;
                    const x = Math.random() * (width - 40) + 20;
                    const ball = Bodies.circle(x, -30, 16, {
                        restitution: 0.5,
                        friction: 0.001,
                        label: 'flagBall',
                        render: { fillStyle: '#ffffff' }
                    });
                    ball.flagData = flag;
                    Composite.add(engine.world, ball);
                }, i * 150);
            });
        }

        // ==========================================
        // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Ø§Ù„Ù…Ø¹Ø±ÙƒØ© Ø§Ù„Ø¯Ø§Ø¦Ø±ÙŠØ©
        // ==========================================
        function transitionToStage2() {
            stage = 1.5;
            setTimeout(() => {
                Composite.clear(engine.world);
                Engine.clear(engine);
                document.getElementById('qualifiers-container').innerHTML = '';
                const titles = {
                    'ar': { main: "Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Ø§Ù„Ù…Ø¹Ø±ÙƒØ© Ø§Ù„Ø¯Ø§Ø¦Ø±ÙŠØ©", sub: "ØµØ§Ø­Ø¨ Ø§Ù„Ù€ 0 Ù†Ù‚Ø§Ø· ÙŠØºØ§Ø¯Ø± ÙˆØ§Ù„Ø¨Ù‚ÙŠØ© ÙŠØªØ£Ù‡Ù„ÙˆÙ†!" },
                    'en': { main: "Stage 2: Circular Battle", sub: "Zero points means elimination! Survivors qualify." }
                };
                document.getElementById('main-title').innerText = titles[currentLang].main;
                document.getElementById('sub-title').innerText = titles[currentLang].sub;
                document.getElementById('main-title').className = "text-2xl font-black text-red-500 tracking-wider animate-pulse";
                
                startStage2();
            }, 2000);
        }

        function startStage2() {
            stage = 2;
            engine.gravity.y = 0; 
            engine.gravity.x = 0;
            stage2Flags = [];
            bullets = [];
            cannonState = 'aiming';
            shotCounter = 0;
            pickNewTargetAngle();

            const radius = Math.min(width, height) * 0.35;
            const centerX = width / 2;
            const centerY = height / 2;
            const angleStep = (Math.PI * 2) / qualifiedFlags.length;

            qualifiedFlags.forEach((flag, i) => {
                const angle = i * angleStep;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                const flagBody = Bodies.circle(x, y, 25, {
                    isStatic: true,
                    isSensor: true, 
                    label: 'targetFlag',
                    render: { fillStyle: '#1e293b', strokeStyle: '#fff', lineWidth: 2 }
                });
                flagBody.flagData = flag;
                flagBody.hp = 100; // Start with 100 HP
                stage2Flags.push(flagBody);
                Composite.add(engine.world, flagBody);
            });
        }

        function repositionStage2Flags() {
            const radius = Math.min(width, height) * 0.35;
            const centerX = width / 2;
            const centerY = height / 2;
            const angleStep = (Math.PI * 2) / stage2Flags.length;

            stage2Flags.forEach((flagBody, i) => {
                const angle = i * angleStep;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                Body.setPosition(flagBody, { x, y });
            });
        }

        function pickNewTargetAngle() {
            cannonTargetAngle = Math.random() * Math.PI * 2;
            cannonState = 'aiming';
        }

        function updateCannonLogic() {
            if (cannonState === 'aiming') {
                let diff = cannonTargetAngle - cannonAngle;
                
                // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø²Ø§ÙˆÙŠØ©
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;

                const rotationSpeed = 0.12; 

                if (Math.abs(diff) < rotationSpeed) {
                    // ÙˆØµÙ„Ù†Ø§ Ù„Ù„Ù‡Ø¯Ù Ø¨Ø¯Ù‚Ø©
                    cannonAngle = cannonTargetAngle;
                    fireCannon();
                    cannonState = 'cooldown';
                    
                    
                    setTimeout(() => {
                        if (stage === 2) pickNewTargetAngle();
                    }, 500); 
                } else {
                    // Ø§Ù„ØªØ­Ø±Ùƒ Ù†Ø­Ùˆ Ø§Ù„Ù‡Ø¯Ù
                    cannonAngle += Math.sign(diff) * rotationSpeed;
                }
            }
        }

        // Helper to get color based on HP
        function getObstacleColor(hp) {
            // Gradient from Red (low) to Green/Blue (high) or similar
            const colors = ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#3b82f6'];
            return colors[hp - 1] || '#3b82f6';
        }

        function fireCannon() {
            const centerX = width / 2;
            const centerY = height / 2;
            
            shotCounter++;
            let bulletVal, bulletRadius, bulletColor;

            // Ù…Ù†Ø·Ù‚ Ø§Ù„ÙƒØ±Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ© (ÙƒÙ„ 10 Ø·Ù„Ù‚Ø§Øª)
            if (shotCounter % 10 === 0) {
                bulletVal = 20;
                bulletRadius = 16;
                bulletColor = '#fbbf24'; // Ù„ÙˆÙ† Ø°Ù‡Ø¨ÙŠ Ø³Ø§Ø·Ø¹
            } else {
                bulletVal = Math.floor(Math.random() * 5) + 5;
                bulletRadius = 10;
                bulletColor = '#8b5cf6'; // Ø¨Ù†ÙØ³Ø¬ÙŠ ÙØ§ØªØ­
            }

            const bullet = Bodies.circle(centerX, centerY, bulletRadius, {
                friction: 0,
                frictionAir: 0,
                label: 'bullet',
                render: { fillStyle: bulletColor }
            });
            bullet.value = bulletVal;
            bullet.isGolden = (shotCounter % 10 === 0);

            const speed = 5;
            Body.setVelocity(bullet, {
                x: Math.cos(cannonAngle) * speed,
                y: Math.sin(cannonAngle) * speed
            });

            bullets.push(bullet);
            Composite.add(engine.world, bullet);
        }

        // ==========================================
        // Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙˆØ§Ù„ØªØµØ§Ø¯Ù…Ø§Øª
        // ==========================================
        function updateLoop() {
            if (stage === 2) {
                updateCannonLogic();

                // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø±ØµØ§ØµØ§Øª Ø§Ù„Ø®Ø§Ø±Ø¬Ø©
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    if (b.position.x < -50 || b.position.x > width + 50 || b.position.y < -50 || b.position.y > height + 50) {
                        Composite.remove(engine.world, b);
                        bullets.splice(i, 1);
                    }
                }
            } else if (stage === 3) {
                updateStage3Logic();
            } else if (stage === 4) {
                updateStage4Logic();
            }
        }

        function handleCollisions(event) {
            event.pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;

                // --- Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1 ---
                if (stage === 1) {
                    let ball = null;
                    if (bodyA.label === 'flagBall' && bodyB.label === 'finishLine') ball = bodyA;
                    if (bodyB.label === 'flagBall' && bodyA.label === 'finishLine') ball = bodyB;

                    if (ball && !qualifiedFlags.includes(ball.flagData)) {
                        qualifiedFlags.push(ball.flagData);
                        
                        const container = document.getElementById('qualifiers-container');
                        const div = document.createElement('div');
                        div.className = 'qualifier-item';
                        div.innerHTML = `<span class="text-xl">${ball.flagData.emoji}</span> <span>${ball.flagData.name}</span>`;
                        container.appendChild(div);

                        Composite.remove(engine.world, ball);

                        if (qualifiedFlags.length >= 10) {
                            transitionToStage2();
                        }
                    }

                    // Breakable Obstacles
                    if (ball && (bodyA.label === 'breakable' || bodyB.label === 'breakable')) {
                        const obstacle = bodyA.label === 'breakable' ? bodyA : bodyB;
                        obstacle.hp--;
                        
                        if (obstacle.hp <= 0) {
                            Composite.remove(engine.world, obstacle);
                            const index = breakables.indexOf(obstacle);
                            if (index > -1) breakables.splice(index, 1);
                        } else {
                            obstacle.render.fillStyle = getObstacleColor(obstacle.hp);
                        }
                        
                        // Small bounce/impulse to ball
                        // Body.applyForce(ball, ball.position, { x: (Math.random()-0.5)*0.005, y: -0.005 });
                    }
                }
                
                // --- Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2 ---
                if (stage === 2) {
                    let bullet = null;
                    let target = null;
                    if (bodyA.label === 'bullet' && bodyB.label === 'targetFlag') { bullet = bodyA; target = bodyB; }
                    if (bodyB.label === 'bullet' && bodyA.label === 'targetFlag') { bullet = bodyB; target = bodyA; }

                    if (bullet && target) {
                        target.hp -= bullet.value; // Decrease HP
                        if (target.hp < 0) target.hp = 0;
                        
                        Composite.remove(engine.world, bullet);
                        const bIndex = bullets.indexOf(bullet);
                        if(bIndex > -1) bullets.splice(bIndex, 1);

                        if (target.hp <= 0) {
                            // Elimination logic moved to global check or trigger transition
                            // For Stage 2, one elim = end stage.
                            
                            // Remove from survivors list for Stage 3 logic
                            const survivorIndex = qualifiedFlags.findIndex(f => f.name === target.flagData.name);
                            if (survivorIndex > -1) {
                                qualifiedFlags.splice(survivorIndex, 1);
                            }
                            
                            endStage2(target.flagData);
                        }
                    }
                }
            });
        }

        // ... (endStage2 and startStage3 functions are above) ...

        // ==========================================
        // Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…Ø®ØµØµ (ØªØªÙ…Ø©)
        // ==========================================
        // Note: renderCustomGraphics is defined above, we need to inject into it.
        // Wait, the previous tool call replaced renderCustomGraphics start. 
        // I need to make sure I'm editing the right place. 
        // The previous tool call ENDED at `ctx.textBaseline = 'middle';` inside `renderCustomGraphics`.
        // So I should continue from there or target the end of the file.
        // Actually, I can just use a large block replacement for the rest of renderCustomGraphics.
        


        function endStage2(loser) {
            stage = 2.5; // Transition
            document.getElementById('winner-ui').style.display = 'flex';
            document.getElementById('winner-flag').innerText = loser.emoji;
            document.getElementById('winner-name').innerText = loser.name;
            
            // Ø¹Ø¯Ø§Ø¯ ØªÙ†Ø§Ø²Ù„ÙŠ Ù„Ù„Ù…Ø±Ø­Ù„Ø© 3
            let timeLeft = 6;
            const countEl = document.getElementById('countdown-text');
            const timer = setInterval(() => {
                timeLeft--;
                countEl.innerText = `Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø© Ø³ØªØ¨Ø¯Ø£ Ø®Ù„Ø§Ù„ ${timeLeft} Ø«ÙˆØ§Ù†Ù...`;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    document.getElementById('winner-ui').style.display = 'none';
                    startStage3();
                }
            }, 1000);
        }

        // ==========================================
        // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Ø´Ø¨ÙƒØ© Ø§Ù„Ù„ÙŠØ²Ø±
        // ==========================================
        function startStage3() {
            stage = 3;
            Composite.clear(engine.world);
            Engine.clear(engine);
            document.getElementById('qualifiers-container').innerHTML = '';
            
            const titles = {
                'ar': { main: "Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Ø´Ø¨ÙƒØ© Ø§Ù„Ù„ÙŠØ²Ø±", sub: "ØªØ¬Ù†Ø¨ Ø§Ù„Ù„ÙŠØ²Ø±! ÙƒÙ„ 3 Ø¬ÙˆÙ„Ø§Øª ÙŠØ²Ø¯Ø§Ø¯ Ù„ÙŠØ²Ø± Ø¥Ø¶Ø§ÙÙŠ." },
                'en': { main: "Stage 3: Laser Grid", sub: "Dodge the lasers! New laser added every 3 cycles." }
            };
            document.getElementById('main-title').innerText = titles[currentLang].main;
            document.getElementById('sub-title').innerText = titles[currentLang].sub;
            document.getElementById('main-title').className = "text-2xl font-black text-purple-500 tracking-wider animate-pulse";

            stage3Flags = [];
            lasers = [];
            laserCycle = 0;
            activeLaserCount = 1;
            laserState = 'idle';
            laserTimer = Date.now();
            diceRolls = [];

            // 3x3 Grid
            // qualifiedFlags should have 9 items now
            const gridSize = 3;
            const cellW = width / gridSize;
            const cellH = height / gridSize;
            
            qualifiedFlags.forEach((flag, i) => {
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                
                const x = col * cellW + cellW/2;
                const y = row * cellH + cellH/2;
                
                const flagBody = Bodies.circle(x, y, 30, {
                    isStatic: true,
                    label: 'stage3Flag',
                     render: { fillStyle: '#1e293b' }
                });
                flagBody.flagData = flag;
                flagBody.hp = 100; // Reset HP for Stage 3
                stage3Flags.push(flagBody);
                Composite.add(engine.world, flagBody);
            });
        }

        function updateStage3Logic() {
            const now = Date.now();
            
            if (laserState === 'idle') {
                if (now - laserTimer > 1000) {
                    // Start Warning
                    laserState = 'warning';
                    laserTimer = now;
                    generateLasers();
                }
            } else if (laserState === 'warning') {
                if (now - laserTimer > 1000) { // 1 sec warning
                    laserState = 'firing';
                    laserTimer = now;
                    checkLaserHits();
                }
            } else if (laserState === 'firing') {
                if (now - laserTimer > 500) { // 0.5 sec firing
                    laserState = 'idle';
                    laserTimer = now;
                    
                    laserCycle++;
                    if (laserCycle % 3 === 0) {
                        activeLaserCount++;
                    }
                }
            }
            
            // Dice Animation
            diceRolls.forEach((dice, i) => {
                if (now - dice.timer > 100) {
                    dice.value = Math.floor(Math.random() * 6) + 1;
                    dice.timer = now;
                    dice.rollsLeft--;
                    if (dice.rollsLeft <= 0) {
                        // Apply Bonus
                        dice.flag.hp += dice.value * 5; // Bonus HP
                        diceRolls.splice(i, 1);
                    }
                }
            });
        }

        function generateLasers() {
            lasers = [];
            for(let i=0; i < activeLaserCount; i++) {
                const isHoriz = Math.random() > 0.5;
                let p1, p2;
                
                if (isHoriz) {
                    p1 = { x: 0, y: Math.random() * height };
                    p2 = { x: width, y: Math.random() * height };
                } else {
                    p1 = { x: Math.random() * width, y: 0 };
                    p2 = { x: Math.random() * width, y: height };
                }
                
                lasers.push({ p1, p2 });
            }
        }

        function checkLaserHits() {
            let deadFlags = [];
            
            lasers.forEach(laser => {
                stage3Flags.forEach(flag => {
                    const dist = distToSegment(flag.position, laser.p1, laser.p2);
                    if (dist < 30) { 
                        flag.hp -= 5;
                    }
                });
            });

            // Check deaths
            stage3Flags.forEach(flag => {
                if (flag.hp <= 0) {
                    deadFlags.push(flag);
                }
            });

            if (deadFlags.length === 1) {
                // One loser
                // Remove loser from qualified
                 const loser = deadFlags[0].flagData;
                 const survivorIndex = qualifiedFlags.findIndex(f => f.name === loser.name);
                 if (survivorIndex > -1) {
                     qualifiedFlags.splice(survivorIndex, 1);
                 }
                endStage3(loser);
            } else if (deadFlags.length > 1) {
                // Tie Breaker
                deadFlags.forEach(flag => {
                    if (!diceRolls.find(d => d.flag === flag)) {
                        diceRolls.push({
                            flag: flag,
                            value: 1,
                            timer: Date.now(),
                            rollsLeft: 20 
                        });
                    }
                });
            }
        }

        function distToSegment(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
        }

        function endStage3(loser) {
            stage = 3.5; // Transition
            document.getElementById('winner-ui').style.display = 'flex';
            const titles = {
                'ar': "ğŸš‘ Ø§Ù„Ù…ØºØ§Ø¯Ø± Ù…Ù† Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3 ğŸš‘",
                'en': "ğŸš‘ Stage 3 Eliminated ğŸš‘"
            };
            document.querySelector('#winner-ui .uppercase').innerText = titles[currentLang];
            document.getElementById('winner-flag').innerText = loser.emoji;
            document.getElementById('winner-name').innerText = loser.name;
            
             let timeLeft = 4;
            const countEl = document.getElementById('countdown-text');
            const timer = setInterval(() => {
                timeLeft--;
                countEl.innerText = `Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø© Ø³ØªØ¨Ø¯Ø£ Ø®Ù„Ø§Ù„ ${timeLeft}...`;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    document.getElementById('winner-ui').style.display = 'none';
                    startStage4();
                }
            }, 1000);
        }

        // ==========================================
        // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: Ø§Ù„ØµÙ†Ø§Ø¯ÙŠÙ‚ Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© (Ghost Box)
        // ==========================================
        
        let stage4State = 'setup'; // setup, ready, revealing, countdown, finished
        let s4Boxes = [];
        let s4RevealTimer = 0;
        let s4FinalCountdown = 6;
        let s4CountdownTimer = 0;

        function startStage4() {
            stage = 4;
            Composite.clear(engine.world);
            Engine.clear(engine);
            document.getElementById('qualifiers-container').innerHTML = '';

            const titles = {
                'ar': { main: "Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„Ø´Ø¨Ø­", sub: "ØµÙ†Ø¯ÙˆÙ‚ ÙˆØ§Ø­Ø¯ ÙÙŠÙ‡ Ø´Ø¨Ø­.. ØªØ¬Ù†Ø¨Ù‡ Ù„ØªØ¹ÙŠØ´!" },
                'en': { main: "Stage 4: Ghost Box", sub: "One box has a ghost.. Avoid it to survive!" }
            };
            document.getElementById('main-title').innerText = titles[currentLang].main;
            document.getElementById('sub-title').innerText = titles[currentLang].sub;
            document.getElementById('main-title').className = "text-2xl font-black text-blue-500 tracking-wider animate-bounce";

            stage4State = 'ready';
            s4Boxes = [];
            
            // Layout: Flags checked on Left, Boxes on Right
            const startY = 100;
            const gapY = (height - 150) / qualifiedFlags.length;
            
            // Create Flags (Left side)
            qualifiedFlags.forEach((flag, i) => {
                const y = startY + i * gapY;
                const flagBody = Bodies.circle(100, y, 25, {
                    isStatic: true,
                    label: 'stage4Flag',
                    render: { fillStyle: '#1e293b' }
                });
                flagBody.flagData = flag;
                Composite.add(engine.world, flagBody);
            });

            // Create Boxes (Right side)
            // Shuffle indices to assign random boxes to flags effectively (visually aligned but logically shuffled?)
            // Actually request says: "Each flag chooses a random box to move next to it".
            // Implementation: Spawn boxes on right, then they move to the flags.
            // Simplified for physics: Spawn boxes next to flags immediately or animate.
            // Let's spawn them next to flags for clarity, but assign the Ghost randomly.
            
            const ghostIndex = Math.floor(Math.random() * qualifiedFlags.length);
            
            qualifiedFlags.forEach((flag, i) => {
                const y = startY + i * gapY;
                const boxBody = Bodies.rectangle(width - 100, y, 50, 50, {
                    isStatic: true,
                    label: 'stage4Box',
                    render: { fillStyle: '#fbbf24' } // Gold/Box color
                });
                
                boxBody.isGhost = (i === ghostIndex);
                boxBody.assignedFlag = flag; // Logical link
                boxBody.isOpen = false;
                boxBody.rowY = y; // target Y
                
                // Animation: Move from right to left (next to flag)
                // We'll handle this in update
                boxBody.targetX = 200; 
                
                s4Boxes.push(boxBody);
                Composite.add(engine.world, boxBody);
            });

            s4RevealTimer = Date.now();
        }

        function updateStage4Logic() {
            const now = Date.now();

            // Animation: Move boxes to flags
            s4Boxes.forEach(box => {
                if (box.position.x > box.targetX) {
                    Body.setPosition(box, { 
                        x: box.position.x - 5, 
                        y: box.position.y 
                    });
                }
            });

            // Wait for boxes to arrive
            if (s4Boxes.some(b => b.position.x > b.targetX + 5)) return;

            if (stage4State === 'ready') {
                stage4State = 'revealing';
                s4RevealTimer = now;
            }

            if (stage4State === 'revealing') {
                // Reveal safe box every 2 seconds
                if (now - s4RevealTimer > 2000) {
                    s4RevealTimer = now;
                    
                    // Filter unrevealed, non-ghost boxes
                    const safeBoxes = s4Boxes.filter(b => !b.isOpen && !b.isGhost);
                    
                    if (safeBoxes.length === 0) {
                        // Only Ghost and maybe one other or just Ghost remaining?
                        // Logic: We reveal until ONLY 2 remain (Ghost + 1 Safe) OR just Ghost if odd?
                        // "Remains empty box and ghost box" -> 2 boxes total.
                        
                        const remaining = s4Boxes.filter(b => !b.isOpen);
                        if (remaining.length <= 2) {
                            stage4State = 'countdown';
                            s4CountdownTimer = now;
                            s4FinalCountdown = 6;
                        }
                        return;
                    }
                    
                    // Pick random safe box to reveal
                    const idx = Math.floor(Math.random() * safeBoxes.length);
                    const box = safeBoxes[idx];
                    box.isOpen = true;
                    box.render.fillStyle = '#22c55e'; // Green/Safe
                }
                
                // Check if we reached the final 2 state manually
                 const remaining = s4Boxes.filter(b => !b.isOpen);
                 if (remaining.length === 2 && remaining.some(b => b.isGhost)) {
                     stage4State = 'countdown';
                     s4CountdownTimer = now;
                     s4FinalCountdown = 6;
                 }
            }

            if (stage4State === 'countdown') {
                if (now - s4CountdownTimer > 1000) {
                    s4CountdownTimer = now;
                    s4FinalCountdown--;
                    if (s4FinalCountdown <= 0) {
                        // TIME UP - REVEAL GHOST
                        stage4State = 'finished';
                        revealGhost();
                    }
                }
            }
        }

        function revealGhost() {
            const ghostBox = s4Boxes.find(b => b.isGhost);
            if (ghostBox) {
                ghostBox.isOpen = true;
                ghostBox.render.fillStyle = '#ef4444'; // Red/Ghost
                
                // Eliminate the flag
                const loserFlag = ghostBox.assignedFlag;
                 // Remove loser from qualified
                 const survivorIndex = qualifiedFlags.findIndex(f => f.name === loserFlag.name);
                 if (survivorIndex > -1) {
                     qualifiedFlags.splice(survivorIndex, 1);
                 }
                 
                setTimeout(() => {
                    endStage4(loserFlag);
                }, 1000);
            }
        }

        function endStage4(loser) {
             document.getElementById('winner-ui').style.display = 'flex';
            const titles = {
                'ar': "ğŸ‘» Ø¶Ø­ÙŠØ© Ø§Ù„Ø´Ø¨Ø­ ğŸ‘»",
                'en': "ğŸ‘» Ghost Victim ğŸ‘»"
            };
            document.querySelector('#winner-ui .uppercase').innerText = titles[currentLang];
            document.getElementById('winner-flag').innerText = loser.emoji;
            document.getElementById('winner-name').innerText = loser.name;
            
             let timeLeft = 4;
            const countEl = document.getElementById('countdown-text');
            const timer = setInterval(() => {
                timeLeft--;
                // Placeholder for Stage 5
                countEl.innerText = `(Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±) Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ÙÙŠ ${timeLeft}...`; 
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    location.reload(); 
                }
            }, 1000);
        }

        function drawStage4(ctx) {
            // Draw overlays for boxes
            s4Boxes.forEach(box => {
                if (box.isOpen) {
                    ctx.save();
                    ctx.translate(box.position.x, box.position.y);
                    ctx.font = "24px Arial";
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(box.isGhost ? "ğŸ‘»" : "âœ…", 0, 0);
                    ctx.restore();
                } else {
                     ctx.save();
                    ctx.translate(box.position.x, box.position.y);
                    ctx.font = "24px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("ğŸ“¦", 0, 0);
                    ctx.restore();
                }
            });

            // Draw Countdown
            if (stage4State === 'countdown') {
                ctx.save();
                ctx.fillStyle = "rgba(255, 0, 0, 0.7)";
                ctx.font = "bold 100px Cairo";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 20;
                ctx.fillText(s4FinalCountdown, width/2, height/2);
                ctx.restore();
            }
        }

        // ==========================================
        // Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…Ø®ØµØµ
        // ==========================================
        function renderCustomGraphics() {
            const ctx = render.context;

            if (stage === 1) {
                const bodies = Composite.allBodies(engine.world);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                bodies.forEach(b => {
                    if (b.label === 'flagBall') {
                        ctx.font = '20px Arial';
                        ctx.fillStyle = '#000'; 
                        ctx.fillText(b.flagData.emoji, b.position.x, b.position.y);
                    }
                    if (b.label === 'breakable') {
                        ctx.font = 'bold 12px Arial';
                        ctx.fillStyle = '#fff';
                        ctx.fillText(b.hp, b.position.x, b.position.y);
                    }
                });
            }
            else if (stage === 2) {
                const cx = width / 2;
                const cy = height / 2;
                
                // Draw Cannon
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(cannonAngle);
                
                // Base
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI*2);
                ctx.fillStyle = '#1e293b';
                ctx.fill();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Barrel
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(0, -12, 60, 24); 
                
                ctx.restore();

                // Bullets
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                bullets.forEach(b => {
                    if (b.isGolden) {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#fbbf24';
                    } else {
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = 'black';
                    ctx.fillText(b.value, b.position.x, b.position.y);
                    
                    ctx.shadowBlur = 0; 
                });

                // Flags
                stage2Flags.forEach(f => {
                    const pos = f.position;
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(f.flagData.emoji, pos.x, pos.y);

                    ctx.font = 'bold 10px Cairo';
                    ctx.fillStyle = '#cbd5e1';
                    ctx.fillText(f.flagData.name, pos.x, pos.y + 25);

                    const radius = 35;
                    const percent = Math.max(f.hp / 100, 0);
                    
                    // HP Circle
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = 4;
                    ctx.stroke();

                    const hue = percent * 120; 
                    const color = `hsl(${hue}, 100%, 50%)`;

                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius, -Math.PI/2, (-Math.PI/2) + (Math.PI * 2 * percent));
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.stroke();

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(Math.ceil(f.hp), pos.x, pos.y - 25);
                });
            }
            else if (stage === 3) {
                // Update Logic handled in updateLoop, just render here
                
                // Draw Flags
                stage3Flags.forEach(f => {
                    const pos = f.position;
                    ctx.font = '34px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(f.flagData.emoji, pos.x, pos.y);
                    
                    ctx.font = 'bold 12px Cairo';
                    ctx.fillStyle = '#cbd5e1';
                    ctx.fillText(f.flagData.name, pos.x, pos.y + 35);
                    
                    const width = 50;
                    const height = 6;
                    const percent = Math.max(f.hp / 100, 0);
                    
                    ctx.fillStyle = '#334155';
                    ctx.fillRect(pos.x - width/2, pos.y - 45, width, height);
                    
                    const hue = percent * 120; 
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.fillRect(pos.x - width/2, pos.y - 45, width * percent, height);
                });

                // Draw Lasers
                lasers.forEach(laser => {
                    ctx.beginPath();
                    ctx.moveTo(laser.p1.x, laser.p1.y);
                    ctx.lineTo(laser.p2.x, laser.p2.y);
                    
                    if (laserState === 'warning') {
                        ctx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([10, 10]);
                    } else if (laserState === 'firing') {
                         ctx.strokeStyle = '#ef4444';
                         ctx.lineWidth = 8;
                         ctx.shadowColor = '#ef4444';
                         ctx.shadowBlur = 20;
                         ctx.setLineDash([]);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;
                });
                
                // Draw Dice
                diceRolls.forEach(dice => {
                    const pos = dice.flag.position;
                    ctx.save();
                    ctx.translate(pos.x, pos.y + 50);
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(-15, -15, 30, 30);
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(dice.value, 0, 2);
                    ctx.restore();
                });
            }
            else if (stage === 4) {
                // Call helper for Stage 4 specific custom drawing (overlays)
                drawStage4(ctx);
                
                // Draw Flags Entities (Stage 4 flags are bodies)
                const bodies = Composite.allBodies(engine.world);
                bodies.forEach(body => {
                    if (body.label === 'stage4Flag') {
                        ctx.font = "24px Arial";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillStyle = '#fff';
                        ctx.fillText(body.flagData.emoji, body.position.x, body.position.y);
                        
                        // Name
                         ctx.font = '10px Cairo';
                         ctx.fillStyle = '#cbd5e1';
                         ctx.fillText(body.flagData.name, body.position.x, body.position.y + 25);
                    }
                });
            }
        }


        window.onload = init;
    </script>
</body>
</html>
